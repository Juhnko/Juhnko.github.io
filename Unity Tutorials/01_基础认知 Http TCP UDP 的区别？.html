
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <!-- common.css -->
      <style>* {-webkit-tap-highlight-color: rgba(0,0,0,0);}html {-webkit-text-size-adjust: none;}body {font-family: -apple-system, Helvetica, Arial, sans-serif;margin: 0;padding: 20px;color: #333;word-wrap: break-word;}h1, h2, h3, h4, h5, h6 {line-height: 1.1;}img {max-width: 100% !important;height: auto;}blockquote {margin: 0;padding: 0 15px;color: #777;border-left: 4px solid #ddd;}hr {background-color: #ddd;border: 0;height: 1px;margin: 15px 0;}code {font-family: Menlo, Consolas, 'Ubuntu Mono', Monaco, 'source-code-pro', monospace;line-height: 1.4;margin: 0;padding: 0.2em 0;font-size: 90%;background-color: rgba(0,0,0,0.04);border-radius: 3px;}pre > code {margin: 0;padding: 0;font-size: 100%;word-break: normal;background: transparent;border: 0;}ol {list-style-type: decimal;}ol ol, ul ol {list-style-type: lower-latin;}ol ol ol, ul ol ol, ul ul ol, ol ul ol {list-style-type: lower-roman;}table {border-spacing: 0;border-collapse: collapse;margin-top: 0;margin-bottom: 16px;}table th {font-weight: bold;}table th, table td {padding: 6px 13px;border: 1px solid #ddd;}table tr {border-top: 1px solid #ccc;}table tr:nth-child(even) {background-color: #f8f8f8;}input[type="checkbox"] {cursor: default;margin-right: 0.5em;font-size: 13px;}.task-list-item {list-style-type: none;}.task-list-item+.task-list-item {margin-top: 3px;}.task-list-item input {float: left;margin: 0.3em 1em 0.25em -1.6em;vertical-align: middle;}#tag-field {margin: 8px 2px 10px;}#tag-field .tag {display: inline-block;background: #cadff3;border-radius: 4px;padding: 1px 8px;color: black;font-size: 12px;margin-right: 10px;line-height: 1.4;}</style>
      <!-- ace-static.css -->
      <style>.ace_static_highlight {white-space: pre-wrap;}.ace_static_highlight .ace_gutter {width: 2em;text-align: right;padding: 0 3px 0 0;margin-right: 3px;}.ace_static_highlight.ace_show_gutter > .ace_line {padding-left: 2.6em;}.ace_static_highlight .ace_line {position: relative;}.ace_static_highlight .ace_gutter-cell {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;user-select: none;top: 0;bottom: 0;left: 0;position: absolute;}.ace_static_highlight .ace_gutter-cell:before {content: counter(ace_line, decimal);counter-increment: ace_line;}.ace_static_highlight {counter-reset: ace_line;}</style>
      <style>.ace-chrome .ace_gutter {background: #ebebeb;color: #333;overflow : hidden;}.ace-chrome .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-chrome {background-color: #FFFFFF;color: black;}.ace-chrome .ace_cursor {color: black;}.ace-chrome .ace_invisible {color: rgb(191, 191, 191);}.ace-chrome .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-chrome .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-chrome .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-chrome .ace_invalid {background-color: rgb(153, 0, 0);color: white;}.ace-chrome .ace_fold {}.ace-chrome .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-chrome .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-chrome .ace_support.ace_type,.ace-chrome .ace_support.ace_class.ace-chrome .ace_support.ace_other {color: rgb(109, 121, 222);}.ace-chrome .ace_variable.ace_parameter {font-style:italic;color:#FD971F;}.ace-chrome .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-chrome .ace_comment {color: #236e24;}.ace-chrome .ace_comment.ace_doc {color: #236e24;}.ace-chrome .ace_comment.ace_doc.ace_tag {color: #236e24;}.ace-chrome .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-chrome .ace_variable {color: rgb(49, 132, 149);}.ace-chrome .ace_xml-pe {color: rgb(104, 104, 91);}.ace-chrome .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-chrome .ace_heading {color: rgb(12, 7, 255);}.ace-chrome .ace_list {color:rgb(185, 6, 144);}.ace-chrome .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-chrome .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-chrome .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-chrome .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-chrome .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-chrome .ace_gutter-active-line {background-color : #dcdcdc;}.ace-chrome .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-chrome .ace_storage,.ace-chrome .ace_keyword,.ace-chrome .ace_meta.ace_tag {color: rgb(147, 15, 128);}.ace-chrome .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-chrome .ace_string {color: #1A1AA6;}.ace-chrome .ace_entity.ace_other.ace_attribute-name {color: #994409;}.ace-chrome .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}</style>
      <!-- export.css -->
      <style>
        body{margin:0 auto;max-width:800px;line-height:1.4}
        #nav{margin:5px 0 10px;font-size:15px}
        #titlearea{border-bottom:1px solid #ccc;font-size:17px;padding:10px 0;}
        #contentarea{font-size:15px;margin:16px 0}
        .cell{outline:0;min-height:20px;margin:5px 0;padding:5px 0;}
        .code-cell{font-family:Menlo,Consolas,'Ubuntu Mono',Monaco,'source-code-pro',monospace;font-size:12px;}
        .latex-cell{white-space:pre-wrap;}
      </style>
      <!-- User CSS -->
      <style> .text-cell {font-size: 15px;}.code-cell {font-size: 12px;}.markdown-cell {font-size: 15px;}.latex-cell {font-size: 15px;}</style>
    </head>
    <body>
      <div id="nav"><div>Previous: <a href='01_Animator动画状态机.html'>01_Animator动画状态机</a>, Up: <a href='index.html'>Index</a></div></div>
      <div id="titlearea">
        <h2>01_基础认知 Http/TCP/UDP 的区别？</h2>
      </div>
      <div id="contentarea"><div class="cell text-cell"><h3><font color="#323232" style="background-color: rgb(254, 250, 0);">TCP/IP/UDP区别与联系？</font></h3><div></div></div><div class="cell text-cell"><div>&nbsp; &nbsp; &nbsp; &nbsp;<b><font color="#323232" style="background-color: rgb(254, 250, 0);">&nbsp;TPC/IP协议是传输层协议</font>，主要解决数据如何<u>在网络中传输</u>，而<font color="#323232" style="background-color: rgb(254, 250, 0);">HTTP是应用层协议</font>，主要解决如何<font><u>包装数据</u></font>。</b><br></div></div><div class="cell text-cell"><div>&nbsp; &nbsp; &nbsp; &nbsp; 关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍："我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 术语TCP/IP代表传输控制协议/网际协议，指的是一系列协议。</div></div><div class="cell text-cell"><div>&nbsp; &nbsp; &nbsp; &nbsp; "IP"代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。<b><font color="#323232" style="background-color: rgb(254, 250, 0);">TCP和UDP是高速公路上的"卡车"</font></b>，它们携带的<b><font color="#323232" style="background-color: rgb(254, 250, 0);">货物就是像HTTP</font></b>，文件传输协议FTP这样的协议等。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;你应该能理解，TCP和UDP是FTP，HTTP和SMTP之类使用的传输层协议。虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。</div><div>&nbsp;　 &nbsp;下面的图表试图显示不同的TCP/IP和其他的协议在最初OSI模型中的位置：</div></div><div class="cell markdown-cell"><p><img src="resources/8D5DB7CBC81D66EAD13496BBE0477BE2.png" alt=""></p>
</div><div class="cell text-cell"><div><br></div><div><br></div><div>TCP/IP是个协议组，可分为三个层次：<b><font color="#323232" style="background-color: rgb(254, 250, 0);">网络层、传输层和应用层。</font></b></div><div><ul><li>&nbsp; &nbsp; &nbsp; 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。<br></li><li>&nbsp; &nbsp; &nbsp; 在传输层中有TCP协议与UDP协议。<br></li><li>&nbsp; &nbsp; &nbsp; 在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。<br></li></ul></div><div>因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。</div></div><div class="cell text-cell"><div></div></div><div class="cell text-cell"><h3>一、HTTP协议（应用层协议）</h3>
</div><div class="cell text-cell"><div><b><font color="#323232" style="background-color: rgb(254, 250, 0);">1、HTTP协议的几个重要概念</font></b></div></div><div class="cell text-cell"><div><b><font color="#323232" style="background-color: rgb(254, 250, 0);"></font></b></div><div><b><font color="#323232" style="background-color: rgb(254, 250, 0);"></font></b></div><div><b><font color="#323232" style="background-color: rgb(254, 250, 0);"></font></b></div><div><span style="caret-color: rgb(50, 50, 50);"><b>&nbsp;</b></span>1. 连接(Connection)：一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。<br></div><div>&nbsp;2. 消息(Message)：HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。</div><div>&nbsp;3. 请求(Request)：一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号</div><div>&nbsp;4. 响应(Response)：一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。</div><div>&nbsp;5. 资源(Resource)：由URI标识的网络数据对象或服务。</div><div>&nbsp;6. 实体(Entity)：数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。</div><div>&nbsp;7. 客户机(Client)：一个为发送请求目的而建立连接的应用程序。</div><div>&nbsp;8. 用户代理(Useragent)：初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。</div><div>&nbsp;9. 服务器(Server)：一个接受连接并对请求返回信息的应用程序。</div><div>&nbsp;10. 源服务器(Originserver)：是一个给定资源可以在其上驻留或被创建的服务器。</div><div>&nbsp;11. 代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;释并且如果可能重写它。</div><div>&nbsp; &nbsp; &nbsp;代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</div><div>&nbsp;12. 网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。</div><div>&nbsp;13. 通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须 &nbsp; 存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</div><div>&nbsp;14. 缓存(Cache)：反应信息的局域存储。</div></div><div class="cell text-cell"><div></div></div><div class="cell text-cell"><div></div><div></div><div><b><font color="#323232" style="background-color: rgb(254, 250, 0);">&nbsp;2.发送请求</font></b><br></div></div><div class="cell text-cell"><div></div><div>打开一个连接后，客户机把请求消息送到服务器的停留端口上，完成提出请求动作。</div><div><br></div><div>&nbsp;HTTP/1.0 请求消息的格式为：</div><div>&nbsp; &nbsp; &nbsp;请求消息=请求行(通用信息|请求头|实体头)CRLF[实体内容]</div><div>&nbsp; &nbsp; &nbsp;请求 行=方法 请求URL HTTP版本号 CRLF</div><div>&nbsp; &nbsp; &nbsp;方法=GET|HEAD|POST|扩展方法</div><div>&nbsp; &nbsp; &nbsp;U R L=协议名称+宿主名+目录与文件名</div><div><br></div><div>&nbsp;请求行中的方法描述指定资源中应该执行的动作，常用的方法有GET、HEAD和POST。不同的请求对象对应GET的结果是不同的，对应关系如下：</div><div>&nbsp; &nbsp; &nbsp;对象 GET的结果</div><div>&nbsp; &nbsp; &nbsp;文件 文件的内容</div><div>&nbsp; &nbsp; &nbsp;程序 该程序的执行结果</div><div>&nbsp; &nbsp; &nbsp;数据库查询 查询结果</div><div><br></div><div>&nbsp;HEAD??要求服务器查找某对象的元信息，而不是对象本身。</div><div>&nbsp;POST??从客户机向服务器传送数据，在要求服务器和CGI做进一步处理时会用到POST方法。POST主要用于发送HTML文本中FORM的内容，让CGI程序处理。</div><div>&nbsp;一个请求的例子为：GEThttp://networking.zju.edu.cn/zju/index.htmHTTP/1.0 networking.zju.edu.cn/zju/index.htmHTTP/1.0&nbsp;</div><div><br></div><div>&nbsp;头信息又称为元信息，即信息的信息，利用元信息可以实现有条件的请求或应答。</div><div>&nbsp;请求头??告诉服务器怎样解释本次请求，主要包括用户可以接受的数据类型、压缩方法和语言等。</div><div>&nbsp;实体头??实体信息类型、长度、压缩方法、最后一次修改时间、数据有效期等。</div><div>&nbsp;实体??请求或应答对象本身。</div></div><div class="cell text-cell"><div></div></div><div class="cell text-cell"><div></div><div><b><font color="#323232" style="background-color: rgb(254, 250, 0);">&nbsp;3.发送响应</font></b></div></div><div class="cell text-cell"><div><b><font color="#323232" style="background-color: rgb(254, 250, 0);"></font></b></div><div>&nbsp;服务器在处理完客户的请求之后，要向客户机发送响应消息。</div><div><br></div><div>&nbsp;HTTP/1.0的响应消息格式如下：</div><div>&nbsp; &nbsp; &nbsp;响应消息=状态行(通用信息头|响应头|实体头) CRLF 〔实体内容〕</div><div>&nbsp; &nbsp; &nbsp;状态行=HTTP版本号 状态码 原因叙述</div><div>&nbsp; &nbsp; &nbsp;状态码表示响应类型</div><div>&nbsp; &nbsp; &nbsp;1×× 保留</div><div>&nbsp; &nbsp; &nbsp;2×× 表示请求成功地接收</div><div>&nbsp; &nbsp; &nbsp;3×× 为完成请求客户需进一步细化请求</div><div>&nbsp; &nbsp; &nbsp;4×× 客户错误</div><div>&nbsp; &nbsp; &nbsp;5×× 服务器错误</div><div><br></div><div>&nbsp;响应头的信息包括：服务程序名，通知客户请求的URL需要认证，请求的资源何时能使用。</div></div><div class="cell text-cell"><div></div><div></div></div><div class="cell text-cell"><div><b><font color="#323232" style="background-color: rgb(254, 250, 0);">4.关闭连接</font></b></div><div><b><font color="#323232" style="background-color: rgb(254, 250, 0);"><br></font></b></div><div>&nbsp; 客户和服务器双方都可以通过关闭套接字来结束TCP/IP对话。</div></div><div class="cell text-cell"></div><div class="cell text-cell"><h3><span style="box-sizing: border-box; outline: 0px; margin: 0px; padding: 0px; word-wrap: break-word; font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-size: 16px; color: rgb(0, 0, 0);"><span style="box-sizing: border-box; outline: 0px; font-weight: 700; word-wrap: break-word;">二、TCP（传输控制协议）</span></span><span style="box-sizing: border-box; outline: 0px; font-weight: 700; word-wrap: break-word; caret-color: rgb(77, 77, 77); color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-size: 16px;">：</span></h3></div><div class="cell text-cell"><div><b>1、TCP是一种面向连接的、可靠的传输层协议；</b></div><div><div><ul><li>&nbsp; TCP协议建立在不可靠的网络层 IP 协议之上，IP协议并不能提供任何可靠性机制，TCP的可靠性完全由自己实现；<br></li><li>&nbsp; TCP采用的最基本的可靠性技术是：确认与超时重传机制、流量控制机制；</li></ul></div></div><div><ol><li>超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。<br></li><li>流量控制就是让发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制。</li></ol></div></div><div class="cell markdown-cell"><p><img src="resources/2317AF2471660D3373E27BF15E72FD9B.jpg" alt="IMAGE" width="892" height="509"></p>
</div><div class="cell text-cell"><div>1. &nbsp; &nbsp;源端口和目的端口字段—— socket（IP+端口号）。TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</div><div>2. &nbsp; 序列号 SEQ ——当前报文段的序号。</div><div>3. &nbsp; 确认应答号 AN ——期望收到对方的下一个报文段的数据的第一个字节的序号；</div><div>4. &nbsp; 紧急  URG ——当  URG  =  1  时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)；</div><div>5. &nbsp; 确认 ACK ——当 ACK = 1 时。表示确认应答号 AN 有效。</div><div>6. &nbsp; 推送  PSH  (PuSH) —— 接收  TCP  收到  PSH  =  1  的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付；</div><div>7. &nbsp; 复位  RST  (ReSeT) —— 当  RST  =  1  时，表明  TCP  连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接；</div><div>8. &nbsp; 同步 SYN —— 同步  SYN  =  1  表示这是一个连接请求报文。</div><div>9. &nbsp; 终止 FIN (Finish) —— 用来释放一个连接。FIN=  1  表明发送端的数据已发送完毕，并要求释放传输连接；</div><div>10. &nbsp; 窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。窗口值是[ 0, 216-1 ]之间的整数；</div><div>11. &nbsp; 检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在TCP 报文段的前面加上 12 字节的伪部(协议字段为6，表示TCP)；</div><div>12. &nbsp; 紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面)；</div><div>13. &nbsp; 选项字段 —— 长度可变。① 最大报文段长度 MSS：MSS是指在TCP连接建立时，收发双发协商的通信时每一个报文段所能承载的数据字段的最大长度（并不是TCP报文段的最大长度，而是：MSS=TCP报文段长度-TCP首部长度），单位为字节（双方提供的MSS中的最小值，为本次连接的最大MSS值）；② 窗口扩大选项；③ 时间戳选项； ④ 选择确认选项；</div></div><div class="cell text-cell"><div><b><font color="#323232" style="background-color: rgb(254, 250, 0);">2、TCP三次握手（非常重要）</font></b></div></div><div class="cell text-cell"><div></div><div>*     第一次握手：客户端向服务器发送请求报文段，其中同步位SYN=1，序号SEQ=x（表明传送数据时的第一个数据字节的序号是x），等待服务器确认；</div><div>*     第二次握手：服务器收到客户端发来的请求，如果同意建立连接，就发回一个确认报文段，该报文段中同步位SYN=1，确认号ACK=x+1，序号SEQ=y；</div><div>*     第三次握手：客户端收到服务器的确认报文段后，还需要向服务器给出确认，向其发送确认包ACK(ack=y+1)，进而完成三次握手。</div><div>通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。</div><div>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</div></div><div class="cell markdown-cell"><p><img src="resources/77A3EFC3A13F95B956EE304701020CE6.jpg" alt="IMAGE" width="869" height="510"></p>
</div><div class="cell markdown-cell"><p><img src="resources/CE34A797556A711F821D4C5C5F3A7E26.jpg" alt="IMAGE" width="880" height="514"></p>
</div><div class="cell markdown-cell"><p><img src="resources/F52C6C469ADE2459455F8AB76412EFC5.jpg" alt="IMAGE" width="858" height="607"></p>
</div><div class="cell markdown-cell"><p><img src="resources/33EE17B83D6AA648A526B7BC36B406F7.jpg" alt="IMAGE" width="856" height="623"></p>
</div><div class="cell markdown-cell"></div><div class="cell text-cell"><h3>三、用户数据报协议（用户报文协议）UDP</h3></div><div class="cell text-cell"><div><ul><li>&nbsp; &nbsp;UDP是一种无连接的、不可靠的传输层协议；<br></li><li>&nbsp; &nbsp;提供了有限的差错检验功能；<br></li><li>&nbsp; &nbsp;目的是希望以最小的开销来达到网络环境中的进程通信目的；</li></ul></div></div><div class="cell text-cell"><div>随着网络技术飞速发展，网速已不再是传输的瓶颈，UDP协议以其简单、传输快的优势，在越来越多场景下取代了TCP，如网页浏览、流媒体、实时游戏、物联网。</div><div><br></div><div><b>1.网速的提升给UDP稳定性提供可靠网络保障</b></div><div>&nbsp; &nbsp; CDN服务商Akamai（NASDAQ: AKAM）报告从2008年到2015年7年时间，各个国家网络平均速率由1.5Mbps提升为5.1Mbps，网速提升近4倍。网络环境变好，网络传输的延迟、稳定性也随之改善，UDP的丢包率低于5%，如果再使用应用层重传，能够完全确保传输的可靠性。</div><div><br></div><div><b>2.对比测试结果UDP性能优于TCP</b></div><div>&nbsp; &nbsp; 为了提升浏览速度，Google基于TCP提出了SPDY协议以及HTTP/2。Google在Chrome上实验基于UDP的QUIC协议，传输速率减少到100ms以内。</div></div><div class="cell markdown-cell"><p><img src="resources/B7AE6CF1F782C4CEF475D5DB241E1E74.jpg" alt="IMAGE" width="1247" height="670"></p>
</div><div class="cell text-cell"><div><b>3.TCP设计过于冗余，速度难以进一步提升</b></div><div>&nbsp; &nbsp; TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程以及重传策略。由于TCP内置在系统协议栈中，极难对其进行改进。<b><br></b></div></div><div class="cell text-cell"><div></div><div><b>4.UDP协议以其简单、传输快的优势，在越来越多场景下取代了TCP</b></div></div><div class="cell text-cell"><div><b>&nbsp; &nbsp; 4.1 网页浏览</b><br></div><div>&nbsp; &nbsp; 使用UDP协议有三个优点 ：</div><div>&nbsp; &nbsp; 能够对握手过程进行精简，减少网络通信往返次数；</div><div>&nbsp; &nbsp; 能够对TLS加解密过程进行优化；</div><div>&nbsp; &nbsp; 收发快速，无阻塞。</div><div><b>&nbsp; &nbsp; 4.2 流媒体</b></div><div>&nbsp; &nbsp; 采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。基于UDP的协议如WebRTC是极佳的选择。</div><div>&nbsp; &nbsp; 2010年google 通过收购 Global IP Solutions，获得了WebRTC（网页实时通信，Web Real-Time Communication）技术，用于提升网页视频速率。</div><div><b>&nbsp; &nbsp; 4.3 实时游戏</b></div><div>&nbsp; &nbsp; 对实时要求较为严格的情况下，采用自定义的可靠UDP协议，比如Enet、RakNet（用户有sony online game、minecraft）等，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。</div><div>&nbsp; &nbsp; 采用UDP的经典游戏如FPS游戏Quake、CS，著名的游戏引擎Unity3D采用的也是RakNet。</div></div><div class="cell text-cell"><div></div></div><div class="cell text-cell"><h3><span style="box-sizing: border-box; outline: 0px; margin: 0px; padding: 0px; word-wrap: break-word; color: rgb(63, 63, 63);"><span style="box-sizing: border-box; outline: 0px; margin: 0px; padding: 0px; word-wrap: break-word; color: rgb(0, 0, 0);">四、TCP与UDP的不同</span></span></h3></div><div class="cell text-cell"><div><b>1. 是否需要建立连接。</b></div><div>&nbsp; &nbsp; &nbsp;UDP在传送数据之前不需要先建立连接；TCP则提供面向连接的服务；</div></div><div class="cell text-cell"><div><b>2. 是否需要给出确认。</b><br></div><div>&nbsp; &nbsp; 对方的传输层在收到UDP报文后，不需要给出任何确认，而 TCP需要给出确认报文，要提供可靠的、面向连接的传输服务。</div></div><div class="cell text-cell"><div><b>3.虽然UDP不提供可靠交付，但在某些情况下UDP是一种最有效的工作方式；【UDP取代TCP】</b></div></div><div class="cell text-cell"><div><b></b></div><div><b>&nbsp;4、和IP层的联系：</b></div><div>&nbsp; &nbsp; IP层只负责把数据送到节点，而不能区分上面的不同应用，所以TCP和UDP协议在其基础上加入了端口的信息，每个端口标识的是一个节点上的一个应用。 除了增加端口信息，UPD协议基本就没有对IP层的数据进行任何的处理了。而TCP协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口，以及接收确认和重发机制，以达到数据的可靠传送。不管应用层看到的是怎样一个稳定的TCP数据流，下面传送的都是一个个的IP数据包，需要由TCP协议来进行数据重组。</div></div><div class="cell text-cell"><div></div></div><div class="cell text-cell"><h3><span style="box-sizing: border-box; outline: 0px; margin: 0px; padding: 0px; word-wrap: break-word; color: rgb(63, 63, 63);"><span style="box-sizing: border-box; outline: 0px; margin: 0px; padding: 0px; word-wrap: break-word; color: rgb(0, 0, 0);">五、TCP与UDP的适用场景</span><span style="box-sizing: border-box; outline: 0px; margin: 0px; padding: 0px; word-wrap: break-word; color: rgb(0, 0, 0);">。</span></span></h3></div><div class="cell text-cell"><div><b>1. TCP用于在传输层有必要实现可靠传输的情况。</b></div><div><b>2. UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。</b></div><div><b><br></b></div><div>&nbsp;   举一个通过 IP 电话进行通话的例子。如果使用 TCP，数据在传送途中如果丢失就会被重发，这样就会导致无法流畅地传输通话人的声音。</div><div>&nbsp; 而采用UDP，它不会进行重发处理，从而也就不会有声音大幅度延迟到达的问题，即使有部分数据丢失，也只是会影响某一小部分的通话。</div><div><br></div></div></div>
      <script>document.body.onkeyup = function(e) {
if (e.keyCode === 37) window.location.href = '01_Animator动画状态机.html';
}</script>
    </body>
    </html>
  