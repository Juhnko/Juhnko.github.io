
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <!-- common.css -->
      <style>* {-webkit-tap-highlight-color: rgba(0,0,0,0);}html {-webkit-text-size-adjust: none;}body {font-family: -apple-system, Helvetica, Arial, sans-serif;margin: 0;padding: 20px;color: #333;word-wrap: break-word;}h1, h2, h3, h4, h5, h6 {line-height: 1.1;}img {max-width: 100% !important;height: auto;}blockquote {margin: 0;padding: 0 15px;color: #777;border-left: 4px solid #ddd;}hr {background-color: #ddd;border: 0;height: 1px;margin: 15px 0;}code {font-family: Menlo, Consolas, 'Ubuntu Mono', Monaco, 'source-code-pro', monospace;line-height: 1.4;margin: 0;padding: 0.2em 0;font-size: 90%;background-color: rgba(0,0,0,0.04);border-radius: 3px;}pre > code {margin: 0;padding: 0;font-size: 100%;word-break: normal;background: transparent;border: 0;}ol {list-style-type: decimal;}ol ol, ul ol {list-style-type: lower-latin;}ol ol ol, ul ol ol, ul ul ol, ol ul ol {list-style-type: lower-roman;}table {border-spacing: 0;border-collapse: collapse;margin-top: 0;margin-bottom: 16px;}table th {font-weight: bold;}table th, table td {padding: 6px 13px;border: 1px solid #ddd;}table tr {border-top: 1px solid #ccc;}table tr:nth-child(even) {background-color: #f8f8f8;}input[type="checkbox"] {cursor: default;margin-right: 0.5em;font-size: 13px;}.task-list-item {list-style-type: none;}.task-list-item+.task-list-item {margin-top: 3px;}.task-list-item input {float: left;margin: 0.3em 1em 0.25em -1.6em;vertical-align: middle;}#tag-field {margin: 8px 2px 10px;}#tag-field .tag {display: inline-block;background: #cadff3;border-radius: 4px;padding: 1px 8px;color: black;font-size: 12px;margin-right: 10px;line-height: 1.4;}</style>
      <!-- ace-static.css -->
      <style>.ace_static_highlight {white-space: pre-wrap;}.ace_static_highlight .ace_gutter {width: 2em;text-align: right;padding: 0 3px 0 0;margin-right: 3px;}.ace_static_highlight.ace_show_gutter > .ace_line {padding-left: 2.6em;}.ace_static_highlight .ace_line {position: relative;}.ace_static_highlight .ace_gutter-cell {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;user-select: none;top: 0;bottom: 0;left: 0;position: absolute;}.ace_static_highlight .ace_gutter-cell:before {content: counter(ace_line, decimal);counter-increment: ace_line;}.ace_static_highlight {counter-reset: ace_line;}</style>
      <style>.ace-chrome .ace_gutter {background: #ebebeb;color: #333;overflow : hidden;}.ace-chrome .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-chrome {background-color: #FFFFFF;color: black;}.ace-chrome .ace_cursor {color: black;}.ace-chrome .ace_invisible {color: rgb(191, 191, 191);}.ace-chrome .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-chrome .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-chrome .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-chrome .ace_invalid {background-color: rgb(153, 0, 0);color: white;}.ace-chrome .ace_fold {}.ace-chrome .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-chrome .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-chrome .ace_support.ace_type,.ace-chrome .ace_support.ace_class.ace-chrome .ace_support.ace_other {color: rgb(109, 121, 222);}.ace-chrome .ace_variable.ace_parameter {font-style:italic;color:#FD971F;}.ace-chrome .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-chrome .ace_comment {color: #236e24;}.ace-chrome .ace_comment.ace_doc {color: #236e24;}.ace-chrome .ace_comment.ace_doc.ace_tag {color: #236e24;}.ace-chrome .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-chrome .ace_variable {color: rgb(49, 132, 149);}.ace-chrome .ace_xml-pe {color: rgb(104, 104, 91);}.ace-chrome .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-chrome .ace_heading {color: rgb(12, 7, 255);}.ace-chrome .ace_list {color:rgb(185, 6, 144);}.ace-chrome .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-chrome .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-chrome .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-chrome .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-chrome .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-chrome .ace_gutter-active-line {background-color : #dcdcdc;}.ace-chrome .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-chrome .ace_storage,.ace-chrome .ace_keyword,.ace-chrome .ace_meta.ace_tag {color: rgb(147, 15, 128);}.ace-chrome .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-chrome .ace_string {color: #1A1AA6;}.ace-chrome .ace_entity.ace_other.ace_attribute-name {color: #994409;}.ace-chrome .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}</style>
      <!-- export.css -->
      <style>
        body{margin:0 auto;max-width:800px;line-height:1.4}
        #nav{margin:5px 0 10px;font-size:15px}
        #titlearea{border-bottom:1px solid #ccc;font-size:17px;padding:10px 0;}
        #contentarea{font-size:15px;margin:16px 0}
        .cell{outline:0;min-height:20px;margin:5px 0;padding:5px 0;}
        .code-cell{font-family:Menlo,Consolas,'Ubuntu Mono',Monaco,'source-code-pro',monospace;font-size:12px;}
        .latex-cell{white-space:pre-wrap;}
      </style>
      <!-- User CSS -->
      <style> .text-cell {font-size: 15px;}.code-cell {font-size: 12px;}.markdown-cell {font-size: 15px;}.latex-cell {font-size: 15px;}</style>
    </head>
    <body>
      <div id="nav"><div>Next: <a href='C#高级进阶教程_01_泛型 约束 协变、逆变.html'>C#高级进阶教程_01_泛型/约束/协变、逆变</a>, Previous: <a href='C#高级进阶教程_00_设计模式_面向对象的第四大特性——抽象_虚方法&抽象方法、抽象类&接口.html'>C#高级进阶教程_00_设计模式_面向对象的第四大特性——抽象_虚方法&抽象方法、抽象类&接口</a>, Up: <a href='index.html'>Index</a></div></div>
      <div id="titlearea">
        <h2>C#高级进阶教程_000_值类型和引用类型</h2>
      </div>
      <div id="contentarea"><div class="cell text-cell"><h2 style="margin: 0px 0px 4px; font-size: 20px; caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;"><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiaodongy/p/7989711.html" style="color: rgb(34, 51, 85); text-decoration: none;"><span style="vertical-align: middle;">C#中的值类型和引用类型</span></a></h2><div class="postbody" style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 14px;"><div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="margin-bottom: 20px; word-break: break-word;"><p style="margin: 10px auto;"><span style="font-size: 12px;">注：下面的示意图主要是为了辅助理解，不代表内存真实情况。</span></p><p style="margin: 10px auto;"><strong><span style="font-size: 16px;">Introduction</span><br></strong></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; 类型基础是C#的基础概念，了解类型基础及背后的工作原理更有助于我们在编码的时候明白数据在内存中的分配与传递。</span><span style="font-size: 13px;">C#提供了值类型<span style="font-family: &quot;Microsoft YaHei&quot;;">和引用类型，值类型</span>如struct, 引用类型如class。 这里主要说明一下它们在内存分配与传递上的区别。</span></p><p style="margin: 10px auto;"><span style="font-size: 16px;"><strong>一 内存分配</strong></span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; 首先要了解一下内存中栈和堆的概念。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;"><strong>&nbsp; &nbsp;<span style="font-size: 14px;">&nbsp;1. 栈（Stack）</span></strong></span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; &nbsp;##栈是一种先进后出的内存结构。</span></p><p style="margin: 10px auto;"><span style="font-size: 12px;">&nbsp; &nbsp;</span>&nbsp;&nbsp;<span style="background-color: rgb(204, 255, 204); font-size: 13px;"><span style="background-color: rgb(255, 255, 255);">方法的调用追踪就是在栈上完成的。比如我们有一个main方法（程序入口）， 在main方法中会调用一个GetPoint的方法。在线程执行时，会将main方法压入栈底（包括编译好的方法指令，参数，和方法内部变量），然后再将GetPoint的方法压入栈底，GetPoint中没有调用其它方法，压栈完毕。出栈顺序是先进后出，也就是后进先出，栈顶的方法GetPoint先执行完毕，然后出栈，所占内存清空，接着main方法执行后出栈，所占内存清空。</span></span></p><div class="cnblogs_code" style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-family: &quot;Courier New&quot; !important; font-size: 12px !important;"><pre style="overflow: auto; margin-top: 0px; margin-bottom: 0px; margin-left: 22px; word-wrap: break-word; font-family: &quot;Courier New&quot; !important;"><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">//</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">示意图：自己脑补吧...</span></pre></div><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; 从上面方法的压栈出栈中可以看出：</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp;&nbsp;<strong>&nbsp;</strong>##栈只能在一端对数据进行操作，也就是栈顶端进行操作。’</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp;&nbsp;<strong>&nbsp;</strong>##栈也是一种内存自我管理的结构，压栈自动分配内存，出栈自动清空所占内存。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; 另外值得注意的两点：</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; &nbsp;##栈中的内存不能动态请求，只能为大小确定的数据分配内存，灵活性不高，但是栈的执行效率很高。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; &nbsp;##栈的可用空间并不大，所以我们在操作分配到栈上的数据时要注意数据的大小带来的影响。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp;<span style="font-size: 14px;">&nbsp;<strong>&nbsp;2.堆（Heap）</strong></span></span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp;</span><span style="font-size: 13px;">&nbsp;<strong>&nbsp;</strong>##堆与栈有所区别，堆在C#中用于存储实实例对象，能存储大量数据，而且堆能够动态分配存储空间。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; &nbsp;##相比栈只能在一端操作，堆中的数据可以随意存取。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; &nbsp;##但堆的结构使得堆的执行效率不如栈高，而且不能自动回收使用过的对象。对于堆中的内存回收，C++程序员需要进行手动回收，这也是C++编程值得注意的一点，否则很容易造成内存溢出。而对于.NET程序员，平台提供了垃圾回收(GC)机制，可以自动回收堆中过期的对象（实现原理大概就是当发现没有“引用”指向此对象时，表明此对象可以回收，此文主要讨论值类型和引用类型，对于GC，感兴趣的可以搜索相关资料）。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;"><strong>&nbsp;&nbsp;</strong><span style="font-size: 14px;"><strong>&nbsp; 3.值类型和引用类型在栈和堆中的分配</strong></span></span></p><p style="margin: 10px auto;"><span style="font-size: 13px;"><strong>&nbsp;</strong></span><span style="font-size: 13px;"><strong>&nbsp;&nbsp;&nbsp;</strong>这儿有两个原则：</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; （1）创建引用类型时，runtime会为其分配两个空间，<strong>一块空间分配在堆上，存储引用类型本身的数据，另一个块空间分配在栈上，存储对堆上数据的引用</strong>（实际上存储的堆上的内存地址，也就是指针）。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; （2）创建值类型时， runtime会为其分配一个空间，这个空间<strong>分配在变量创建的地方</strong>，如：</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; &nbsp;&nbsp; ##如果值类型是在方法内部创建，则跟随方法入栈，分配到栈上存储。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; &nbsp; ##如果值类型是引用类型的成员变量，则跟随引用类型，存储在堆上。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp;在此我们举例说明。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp;定义一个Point类：&nbsp;&nbsp;</span></p><div class="cnblogs_code" style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-family: &quot;Courier New&quot; !important; font-size: 12px !important;"><pre style="overflow: auto; margin-top: 0px; margin-bottom: 0px; margin-left: 22px; word-wrap: break-word; font-family: &quot;Courier New&quot; !important;"> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">public</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">class</span><span style="line-height: 1.5 !important;"> Point
   {
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">public</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span> PointX { <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">get</span>; <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">set</span><span style="line-height: 1.5 !important;">; }
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">public</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span> PointY { <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">get</span>; <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">set</span><span style="line-height: 1.5 !important;">; }   </span><span style="line-height: 1.5 !important;">
    }</span></pre></div><p style="margin: 10px auto;"><span style="font-size: 13px;">StartProgram类，有方法Start()和InitialPoint()：</span></p><div class="cnblogs_code" style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-family: &quot;Courier New&quot; !important; font-size: 12px !important;"><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); border: none !important;"><img src="resources/51E409B11AA51C150090697429A953ED.gif" alt="复制代码" style="border: none !important;" width="20" height="20"></a></span></div><pre style="overflow: auto; margin-top: 0px; margin-bottom: 0px; margin-left: 22px; word-wrap: break-word; font-family: &quot;Courier New&quot; !important;">  <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">class</span><span style="line-height: 1.5 !important;"> StartProgram
    {
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">void</span><span style="line-height: 1.5 !important;"> Start()
        {
            </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span> pointX = <span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">100.1</span><span style="line-height: 1.5 !important;">;
            InitialPoint(pointX);
        }
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">void</span> InitialPoint(<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span><span style="line-height: 1.5 !important;"> pointX)
        {
            </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">var</span> point = <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">new</span><span style="line-height: 1.5 !important;"> Point();
            point.PointX </span>=<span style="line-height: 1.5 !important;"> pointX;
        }
    }</span></pre><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); border: none !important;"><img src="resources/51E409B11AA51C150090697429A953ED.gif" alt="复制代码" style="border: none !important;" width="20" height="20"></a></span></div></div><p style="margin: 10px auto;"><span style="font-size: 13px;">示例分析：假设</span><span style="font-size: 13px;">主线程从Start()进入执行，我们从分析一下方法中的变量在内存中的大致分配情况，不深究细节。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp;首先将Start()方法指令压入栈底，然后压入局部变量pointX；紧接着将InitialPoint()方法压入栈底，形参pointX压入栈底，在堆上实例化Point对象(包括其成员变量PointX和PointY)，并在栈上创建point变量指向堆上的Point对象，最后给成员变量PointX赋值，</span><span style="font-size: 13px;">参考图如下：</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp;<span style="font-size: 12px;">&nbsp;注：注意不要混淆code中的pointx，虽然变量名相同，但是它们是不同的变量。&nbsp;</span></span></p><p style="margin: 10px auto;">&nbsp;<img src="resources/922AD7BD6778370A158CE2191FBFADA7.png" alt="" style="border: 0px;" width="293" height="214">&nbsp; &nbsp; &nbsp;<img src="resources/A82B87D0CAC99CFB89D79D93333AA496.png" alt="" style="border: 0px;" width="108" height="103"><img src="resources/4B01F42CC337119549DBBA0BFCEAE6AB.png" alt="" style="border: 0px;" width="297" height="215"></p><p style="margin: 10px auto;">&nbsp;</p><p style="margin: 10px auto;"><strong><span style="font-size: 15px;">二 数据传递</span><br></strong></p><p style="margin: 10px auto;"><strong>&nbsp;&nbsp;&nbsp;1.按值传递原则</strong></p><p style="margin: 10px auto;"><strong><span style="font-size: 15px;">&nbsp;&nbsp;</span></strong><span style="font-size: 15px;"><span style="font-size: 13px;">&nbsp;在C#中数据传递默认按值传递，先看一个示例。</span></span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp;现在有一个结构体PointSturct， 一个类PointClass：</span></p><div class="cnblogs_code" style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-family: &quot;Courier New&quot; !important; font-size: 12px !important;"><pre style="overflow: auto; margin-top: 0px; margin-bottom: 0px; margin-left: 22px; word-wrap: break-word; font-family: &quot;Courier New&quot; !important;">  <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">public</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">struct</span><span style="line-height: 1.5 !important;"> PointStruct
    {
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">public</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span> PointX { <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">get</span>; <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">set</span><span style="line-height: 1.5 !important;">; }
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">public</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span> PointY { <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">get</span>; <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">set</span><span style="line-height: 1.5 !important;">; }   
    }</span></pre></div><div class="cnblogs_code" style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-family: &quot;Courier New&quot; !important; font-size: 12px !important;"><pre style="overflow: auto; margin-top: 0px; margin-bottom: 0px; margin-left: 22px; word-wrap: break-word; font-family: &quot;Courier New&quot; !important;">  <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">public</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">class</span><span style="line-height: 1.5 !important;"> PointClass
    {
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">public</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span> PointX { <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">get</span>; <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">set</span><span style="line-height: 1.5 !important;">; }
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">public</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span> PointY { <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">get</span>; <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">set</span><span style="line-height: 1.5 !important;">; }   
    }</span></pre></div><p style="margin: 10px auto;"><span style="font-size: 13px;">并在一个方法中执行执行以下代码：</span></p><div class="cnblogs_code" style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-family: &quot;Courier New&quot; !important; font-size: 12px !important;"><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); border: none !important;"><img src="resources/51E409B11AA51C150090697429A953ED.gif" alt="复制代码" style="border: none !important;" width="20" height="20"></a></span></div><pre style="overflow: auto; margin-top: 0px; margin-bottom: 0px; margin-left: 22px; word-wrap: break-word; font-family: &quot;Courier New&quot; !important;"><span style="color: rgb(0, 128, 128); line-height: 1.5 !important;">1</span>  <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">void</span><span style="line-height: 1.5 !important;"> Excute()
</span><span style="color: rgb(0, 128, 128); line-height: 1.5 !important;">2</span> <span style="line-height: 1.5 !important;"> {
</span><span style="color: rgb(0, 128, 128); line-height: 1.5 !important;">3</span>       <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">var</span> pointStruct1 = <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">new</span><span style="line-height: 1.5 !important;"> PointStruct();
</span><span style="color: rgb(0, 128, 128); line-height: 1.5 !important;">4</span>       <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">var</span> pointClass1 = <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">new</span><span style="line-height: 1.5 !important;"> PointClass();
</span><span style="color: rgb(0, 128, 128); line-height: 1.5 !important;">5</span>       <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">var</span> pointStruct2 =<span style="line-height: 1.5 !important;"> pointStruct1;
</span><span style="color: rgb(0, 128, 128); line-height: 1.5 !important;">6</span>       <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">var</span> pointClass2 =<span style="line-height: 1.5 !important;"> pointClass1;
</span><span style="color: rgb(0, 128, 128); line-height: 1.5 !important;">7</span>   }　　　　　　</pre><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); border: none !important;"><img src="resources/51E409B11AA51C150090697429A953ED.gif" alt="复制代码" style="border: none !important;" width="20" height="20"></a></span></div></div><p style="margin: 10px auto;"><span style="font-size: 13px;">示例分析：第3，4行代码分别创建了一个结构体pointStruct1和一个类实例pointClass1, 结合上面的内存分配规则，对于pointSturct1，会在栈上分配内存存储其数据本身，对于pointClass1，会在堆上分配内存存储实例，且在栈上存储指向实例的引用，参考图如下：</span></p><p style="margin: 10px auto;"><img src="resources/69A352B9E3363ADE7E82BCB3980E42A2.png" alt="" style="border: 0px;" width="291" height="172"></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; &nbsp;经过执行5，6行代码后，内存分配应该是怎样的呢？ 对于值类型（pointStruct1），会在栈上开辟一块新的空间，将数据复制一份新的过去，因此pointStruct2和pointStruct1是<strong>互相独立</strong>的，对其中一个的修改不会影响到另一个；对于引用类型（pointClass1），也会在栈上开辟一个新的空间，<strong>将栈上的引用复制到新的空间</strong>， 但是注意，此处复制的是栈上存储的引用，也就是说栈上的两个变量pointClass1和pointClass2虽然是不同的空间，但是它们存储的引用， 都是指向堆上的同一实例，所以当通过pointClass2对实例的数据进行修改以后，通过pointClass1再访问实例的数据，将会是修改过的数据，反之亦然。对于复制引用，我们打个比方，假如把堆上的实例比作学校，A同学记录了学校的地址（引用），现在又来了B同学，复制引用就好比A同学把学校的地址抄了一份给B同学。</span><span style="font-size: 13px;">参考图如下：</span></p><p style="margin: 10px auto;"><img src="resources/22B972C8EA3C8BA2876636933507BD36.png" alt="" style="border: 0px;" width="303" height="174"></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp;&nbsp;<strong><span style="font-size: 14px;">&nbsp; 2.参数传递</span></strong></span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; &nbsp;当程序中进行参数传递的时候，也是默认按值传递，<strong>值类型复制数据本身，形成独立的数据块，引用类型复制引用，指向同一实例</strong>。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">我们将之前的StartProgram类中的方法改成如下 ：</span></p><div class="cnblogs_code" style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-family: &quot;Courier New&quot; !important; font-size: 12px !important;"><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); border: none !important;"><img src="resources/51E409B11AA51C150090697429A953ED.gif" alt="复制代码" style="border: none !important;" width="20" height="20"></a></span></div><pre style="overflow: auto; margin-top: 0px; margin-bottom: 0px; margin-left: 22px; word-wrap: break-word; font-family: &quot;Courier New&quot; !important;"><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">class</span><span style="line-height: 1.5 !important;"> StartProgram
{
   </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">void</span><span style="line-height: 1.5 !important;"> Start()
   {
      </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span> pointX1 = <span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">100.1</span><span style="line-height: 1.5 !important;">;
      </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">var</span> point1 = <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">new</span><span style="line-height: 1.5 !important;"> Point();
      point1.PointX </span>= <span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">200.1</span><span style="line-height: 1.5 !important;">;
      InitialPoint(pointX1, point1);
      Console.WriteLine(</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">string</span>.Format(<span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">"</span><span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">pointX1:{0}</span><span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">"</span><span style="line-height: 1.5 !important;">, pointX1));
      Console.WriteLine(</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">string</span>.Format(<span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">"</span><span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">point1.PointX:{0}</span><span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">"</span><span style="line-height: 1.5 !important;">, point1.PointX));
      Console.ReadKey();
    }
    </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">void</span> InitialPoint(<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span><span style="line-height: 1.5 !important;"> pointX2, Point point2)
    {
       pointX2 </span>= <span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">300.1</span><span style="line-height: 1.5 !important;">;
       point2.PointX </span>=<span style="line-height: 1.5 !important;"> pointX2;
    }
 }
</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">/*</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">Output:pointX1:100.1
         point1.PointX:300.1 <br></span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;"> */</span></pre><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); border: none !important;"><img src="resources/51E409B11AA51C150090697429A953ED.gif" alt="复制代码" style="border: none !important;" width="20" height="20"></a></span></div></div><p style="margin: 10px auto;"><span style="font-size: 13px;">示例分析：从输出结果可以看到，pointX1还是原来的值，没有受到pointX2影响，而point1.PointX的值是point2对PointX更改后的值。在内存中，将值类型pointX1传递给pointX2后，在栈上形成两个独立的内存块，因此对pointX2更改后，并不会影响到pointX1；而对于引用类型point1，传递给point2后，它们两块内存存储的引用指向同一实例，因此再InitialPoint()方法内对point2.PointX赋值为300.1后，再Start()方法里面取point1取PointX的值，也是300.1。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">既然point1和point2指向同一实例，那么如果我们在InitialPoint()方法的最后将point2设置为null，会不会影响到Start()方法里的point1呢？用point.PointX取值的时候，会不会得到实例为null的异常呢？</span></p><div class="cnblogs_code" style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-family: &quot;Courier New&quot; !important; font-size: 12px !important;"><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); border: none !important;"><img src="resources/51E409B11AA51C150090697429A953ED.gif" alt="复制代码" style="border: none !important;" width="20" height="20"></a></span></div><pre style="overflow: auto; margin-top: 0px; margin-bottom: 0px; margin-left: 22px; word-wrap: break-word; font-family: &quot;Courier New&quot; !important;"> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">void</span> InitialPoint(<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span><span style="line-height: 1.5 !important;"> pointX2, Point point2)
 {
    pointX2 </span>= <span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">300.1</span><span style="line-height: 1.5 !important;">;
    point2.PointX </span>=<span style="line-height: 1.5 !important;"> pointX2;
    point2 </span>= <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">null</span><span style="line-height: 1.5 !important;">;
 }
 </span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">/*</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">Output:pointX1:100.1
          point1.PointX:300.1 
 </span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">*/</span></pre><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); border: none !important;"><img src="resources/51E409B11AA51C150090697429A953ED.gif" alt="复制代码" style="border: none !important;" width="20" height="20"></a></span></div></div><p style="margin: 10px auto;"><span style="font-size: 13px;">示例分析：</span><span style="font-size: 13px;">还是会得到之前的结果，没有检测到null异常。这是因为point2设置为null的含义是，<strong>并不是将堆上的实例变为null，而是设置栈上的引用为null</strong>，注意，这和上一句代码</span>point2.PointX = pointX2是有区别的，上一句代码的含义是，通过point2引用找到<strong>堆上的实例</strong>，对其属性PointX进行更新。将point2设置为null后，<span style="font-size: 13px;">point1仍然指向堆上的实例，因此可以访问到更新后的实例属性值。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp; &nbsp;我们也用上面的学校作类比，学校表示堆上的实例，A同学和B同学都有学校的地址（引用），将point2设置为null，就相当于销毁B同学的地址，让B同学找不到学校了，但是A同学仍然可以去学校，以及可以看到B同学之前在学校完成的作业（point2设置为null之前对实例数据的更新）。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">参考图如下：</span></p><p style="margin: 10px auto;"><img src="resources/6B280FD6B2B414FAC7C4F28B4FB76234.png" alt="" style="border: 0px;" width="289" height="177"><img src="resources/6A1D74CF26974AA6DD5C5F947C3E2A93.png" alt="" style="border: 0px;" width="121" height="111"><img src="resources/6A5944C4596463BCD54D7708850E6BFE.png" alt="" style="border: 0px;" width="288" height="169"></p><p style="margin: 10px auto;"><strong>&nbsp; &nbsp; 3.按引用传递（Ref和Out关键字）</strong></p><p style="margin: 10px auto;">&nbsp; &nbsp;&nbsp;<span style="font-size: 12px;">注：Ref和Out的区别在于Ref在传递前需要初始化。</span></p><p style="margin: 10px auto;"><span style="font-size: 13px;">&nbsp; &nbsp;我们知道C#中的Ref和Out关键字可以在值类型的传参上实现跟引用类型一样的效果，那么在引用类型参数上加入ref和out关键字跟默认的引用类型传参有什么区别呢？很多人觉得应该没有什么用，其实不然，我们继续将StartProgram类的方法改为按ref传递，看看会有什么不同。</span></p><div class="cnblogs_code" style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-family: &quot;Courier New&quot; !important; font-size: 12px !important;"><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); border: none !important;"><img src="resources/51E409B11AA51C150090697429A953ED.gif" alt="复制代码" style="border: none !important;" width="20" height="20"></a></span></div><pre style="overflow: auto; margin-top: 0px; margin-bottom: 0px; margin-left: 22px; word-wrap: break-word; font-family: &quot;Courier New&quot; !important;"><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">class</span><span style="line-height: 1.5 !important;"> StartProgram
{</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">void</span><span style="line-height: 1.5 !important;"> Start()
    {
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span> pointX1 = <span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">100.1</span><span style="line-height: 1.5 !important;">;
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">var</span> point1 = <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">new</span><span style="line-height: 1.5 !important;"> Point();
        point1.PointX </span>= <span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">200.1</span><span style="line-height: 1.5 !important;">;
        InitialPoint(</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">ref</span> pointX1, <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">ref</span><span style="line-height: 1.5 !important;"> point1);
        Console.WriteLine(</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">string</span>.Format(<span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">"</span><span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">pointX1:{0}</span><span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">"</span><span style="line-height: 1.5 !important;">, pointX1));
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">if</span> (point1 != <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">null</span>) Console.WriteLine(<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">string</span>.Format(<span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">"</span><span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">point1.PointX:{0}</span><span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">"</span><span style="line-height: 1.5 !important;">, point1.PointX));
        </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">else</span> Console.WriteLine(<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">string</span>.Format(<span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">"</span><span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">point1 is null</span><span style="color: rgb(128, 0, 0); line-height: 1.5 !important;">"</span><span style="line-height: 1.5 !important;">));
        Console.ReadKey();
    }
    </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">void</span> InitialPoint(<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">ref</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">double</span> pointX2, <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">ref</span><span style="line-height: 1.5 !important;"> Point point2)
    {
        pointX2 </span>= <span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">300.1</span><span style="line-height: 1.5 !important;">;
        point2.PointX </span>=<span style="line-height: 1.5 !important;"> pointX2;
        point2 </span>= <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">null</span><span style="line-height: 1.5 !important;">;
    }
    </span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">/*</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">Output:<br>             pointX1:300.1
             point1 is null
    </span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">*/<br></span><span style="line-height: 1.5 !important;"> }</span></pre><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); border: none !important;"><img src="resources/51E409B11AA51C150090697429A953ED.gif" alt="复制代码" style="border: none !important;" width="20" height="20"></a></span></div></div><p style="margin: 10px auto;"><span style="font-size: 13px;">示例分析：从运行结果可以看到，对于值类型， pointX2对值的更改影响到了pointX1；对于引用类型，将point2设置为null后，point1也变成了null，之前我们没有加ref参数的时候，point2设置为null，并不会影响到point1本身。我们可以看到，通过加入ref和out参数后，在内存中并不是像值传递一样将栈上的数据拷贝一份到新的空间。在这里，我并没有去研究C#对ref和out参数在内存上的实现原理，有兴趣的可以深入研究。</span></p><p style="margin: 10px auto;"><strong><span style="font-size: 15px;">Summary</span></strong></p><p style="margin: 10px auto;"><strong><span style="font-size: 15px;">&nbsp; &nbsp;</span></strong><span style="font-size: 13px;">本文从内存中栈和堆的结构特点出发，分析了C#值类型和引用类型在栈和堆上的分配情况，接着分析了数据传递过程，包括按值传递（赋值，参数传递），按引用传递（ref，out关键字），仅供参考。</span></p></div></div></div></div>
      <script>document.body.onkeyup = function(e) {
if (e.keyCode === 39) window.location.href = 'C#高级进阶教程_01_泛型 约束 协变、逆变.html';
if (e.keyCode === 37) window.location.href = 'C#高级进阶教程_00_设计模式_面向对象的第四大特性——抽象_虚方法&抽象方法、抽象类&接口.html';
}</script>
    </body>
    </html>
  